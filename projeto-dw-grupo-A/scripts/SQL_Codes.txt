    "-- ============================================================\n",
    "-- 1) ANÁLISE TEMPORAL — Receita total ao longo do tempo (por Ano e Mês)\n",
    "-- Lógica Python Original: orders.merge(order_items).groupby(['year', 'month']).agg(total_revenue=('revenue', 'sum'))\n",
    "-- Objetivo: Calcular a receita total (preço + frete) agrupada por ano e mês da compra.\n",
    "-- Nota: As funções `strftime('%Y', ...)` e `strftime('%m', ...)` são utilizadas aqui como exemplo de extração de data, comuns em SQLite ou adaptáveis em outros SGBDs (ex: `EXTRACT(YEAR FROM ...)`).\n",
    "-- ============================================================\n",
    "SELECT\n",
    "    CAST(strftime('%Y', t1.order_purchase_timestamp) AS INTEGER) AS year,\n",
    "    CAST(strftime('%m', t1.order_purchase_timestamp) AS INTEGER) AS month,\n",
    "    SUM(t2.price + t2.freight_value) AS total_revenue\n",
    "FROM olist_orders_dataset t1\n",
    "JOIN olist_order_items_dataset t2\n",
    "    ON t1.order_id = t2.order_id\n",
    "GROUP BY 1, 2\n",
    "ORDER BY 1, 2;\n"
   ],
   "metadata": {
    "id": "temporal_sql"
   }
  },
  {
   "cell_type": "code",
   "source": [
    "-- ============================================================\n",
    "-- 2) RANKING / TOP N — Top 10 categorias de produtos mais vendidas\n",
    "-- Lógica Python Original: order_items.merge(products).groupby('product_category_name').agg(qtd_vendida=('order_id', 'count')).head(10)\n",
    "-- Objetivo: Listar as 10 categorias de produtos com maior quantidade de itens vendidos.\n",
    "-- ============================================================\n",
    "SELECT\n",
    "    t3.product_category_name,\n",
    "    COUNT(t1.order_id) AS qtd_vendida\n",
    "FROM olist_order_items_dataset t1\n",
    "LEFT JOIN olist_products_dataset t3\n",
    "    ON t1.product_id = t3.product_id\n",
    "GROUP BY t3.product_category_name\n",
    "ORDER BY qtd_vendida DESC\n",
    "LIMIT 10;\n"
   ],
   "metadata": {
    "id": "ranking_sql"
   }
  },
  {
   "cell_type": "code",
   "source": [
    "-- ============================================================\n",
    "-- 3) AGREGAÇÃO MULTIDENSIONAL — Vendas por Categoria e por Estado do Cliente\n",
    "-- Lógica Python Original: order_items.merge(products).merge(orders).merge(customers).groupby(['category', 'state']).agg(qtd_vendas=('order_id', 'count'), ticket_medio=('ticket', 'mean'))\n",
    "-- Objetivo: Analisar a quantidade de itens vendidos e o ticket médio (preço + frete) por categoria de produto e estado do cliente.\n",
    "-- ============================================================\n",
    "SELECT\n",
    "    t3.product_category_name,\n",
    "    t4.customer_state,\n",
    "    COUNT(t1.order_id) AS qtd_vendas, -- Contagem de itens vendidos (item lines)\n",
    "    AVG(t1.price + t1.freight_value) AS ticket_medio\n",
    "FROM olist_order_items_dataset t1\n",
    "JOIN olist_products_dataset t3\n",
    "    ON t1.product_id = t3.product_id\n",
    "JOIN olist_orders_dataset t2\n",
    "    ON t1.order_id = t2.order_id\n",
    "JOIN olist_customers_dataset t4\n",
    "    ON t2.customer_id = t4.customer_id\n",
    "GROUP BY t3.product_category_name, t4.customer_state\n",
    "ORDER BY qtd_vendas DESC, ticket_medio DESC;\n"
   ],
   "metadata": {
    "id": "multidimensional_sql"
   }
  },
  {
   "cell_type": "code",
   "source": [
    "-- ============================================================\n",
    "-- 4) ANÁLISE DE COHORT — Novos Clientes por Mês de Aquisição\n",
    "-- Lógica Python Original: orders.groupby('customer_id')['order_purchase_timestamp'].transform('min').groupby('first_purchase_month').count()\n",
    "-- Objetivo: Identificar o número de clientes que fizeram sua primeira compra em cada mês (mês de aquisição).\n",
    "-- Utiliza a função de janela/agregação `MIN()` com `GROUP BY` e uma Common Table Expression (CTE) para simplificar.\n",
    "-- ============================================================\n",
    "WITH ClientePrimeiraCompra AS (\n",
    "    -- Encontra a data da primeira compra para cada cliente\n",
    "    SELECT\n",
    "        customer_id,\n",
    "        MIN(order_purchase_timestamp) AS primeira_compra_data\n",
    "    FROM olist_orders_dataset\n",
    "    GROUP BY customer_id\n",
    ")\n",
    "SELECT\n",
    "    -- Extrai o ano-mês (formato 'YYYY-MM') da primeira compra para agrupar o cohort\n",
    "    strftime('%Y-%m', primeira_compra_data) AS first_purchase_month,\n",
    "    COUNT(customer_id) AS novos_clientes\n",
    "FROM ClientePrimeiraCompra\n",
    "GROUP BY first_purchase_month\n",
    "ORDER BY first_purchase_month;\n"
   ],
   "metadata": {
    "id": "cohort_sql"
   }
  },
  {
   "cell_type": "code",
   "source": [
    "-- ============================================================\n",
    "-- 5) KPI — Ticket Médio e Quantidade de Itens Vendidos por Estado\n",
    "-- Lógica Python Original: order_items.merge(orders).merge(customers).groupby('customer_state').agg(ticket_medio=('ticket', 'mean'), qtd_pedidos=('order_id', 'count')).sort_values('ticket_medio', ascending=False)\n",
    "-- Objetivo: Calcular o ticket médio (preço + frete) e a quantidade de *itens vendidos* por estado do cliente.\n",
    "-- ============================================================\n",
    "SELECT\n",
    "    t3.customer_state,\n",
    "    AVG(t1.price + t1.freight_value) AS ticket_medio,\n",
    "    COUNT(t1.order_id) AS qtd_itens_vendidos -- Contagem do número de item lines/vendas de produtos (para replicar a lógica do Pandas)\n",
    "FROM olist_order_items_dataset t1\n",
    "JOIN olist_orders_dataset t2\n",
    "    ON t1.order_id = t2.order_id\n",
    "JOIN olist_customers_dataset t3\n",
    "    ON t2.customer_id = t3.customer_id\n",
    "GROUP BY t3.customer_state\n",
    "ORDER BY ticket_medio DESC;\n"
   ],
   "metadata": {
    "id": "kpi_sql"
   }
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}